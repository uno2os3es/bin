#!/data/data/com.termux/files/usr/bin/env python3
"""Normalize permissions in Termux with multiprocessing.

Updates:
- Non-executable text-based files forced to 0644
- Exclude ".git"
"""

import os
import stat
import sys
from datetime import datetime
from multiprocessing import Pool, cpu_count

DIR_MODE = 0o755
FILE_MODE = 0o644
EXEC_MODE = 0o755

# Extensions that should NEVER be executable
FORCE_NON_EXEC = {
    '.md',
    '.markdown',
    '.txt',
    '.json',
    '.yaml',
    '.yml',
    '.ini',
    '.cfg',
    '.conf',
    '.toml',
    '.csv',
    '.tsv',
    '.log',
    '.rst',
    '.html',
    '.htm',
    '.xml',
    '.png',
    '.jpg',
    '.py',
    '.pyi',
    '.gitignore',
}

# Explicitly executable extensions
EXEC_EXTENSIONS = {'.sh'}

EXCLUDED_DIRS = {'.git'}


def is_executable_file(path: str) -> bool:
    """Decide if file should be executable, ignoring FORCE_NON_EXEC protections."""
    try:
        if not os.path.isfile(path):
            return False

        _, ext = os.path.splitext(path)
        ext = ext.lower()

        # Text-based files are NEVER executable
        if ext in FORCE_NON_EXEC:
            return False

        st = os.stat(path)

        # If already executable
        if st.st_mode & stat.S_IXUSR:
            return False

        # Extension-based executables
        if ext in EXEC_EXTENSIONS:
            return True

        # Shebang-based executables
        with open(path, 'rb') as f:
            if f.read(2) == b'#!':
                return True

        return False

    except Exception:
        return False


def handle_item(item) -> None:
    kind, path = item

    try:
        if kind == 'dir':
            os.chmod(path, DIR_MODE)
            return

        if os.path.islink(path):
            return

        # Determine extension early
        _, ext = os.path.splitext(path)
        ext = ext.lower()

        # Force non-executable extensions to 0644
        if ext in FORCE_NON_EXEC:
            os.chmod(path, FILE_MODE)
            return

        # Normal executable detection
        if is_executable_file(path):
            os.chmod(path, EXEC_MODE)
        else:
            os.chmod(path, FILE_MODE)

    except Exception as e:
        print(f'[ERR ] Cannot chmod {path}: {e}')


def collect_paths(root):
    items = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if d not in EXCLUDED_DIRS]
        items.append(('dir', dirpath))
        for name in filenames:
            items.append(('file', os.path.join(dirpath, name)))
    return items


def main() -> None:
    if len(sys.argv) != 2:
        print(f'Usage: python3 {sys.argv[0]} <path>')
        sys.exit(1)

    target = os.path.abspath(sys.argv[1])

    items = collect_paths(target)

    workers = max(1, cpu_count() - 1)
    with Pool(workers) as pool:
        pool.map(handle_item, items)


if __name__ == '__main__':
    main()
